set -e

########################################################################
# Logging
#

ESC="$(printf '\033')"
NORMAL="${ESC}[0m"
RED="${ESC}[31;1m"
GREEN="${ESC}[32;1m"
YELLOW="${ESC}[33;1m"
BLUE="${ESC}[34;1m"
BEGINNING="$(printf '\015\033')[K"

log_begin_msg () {
    printf "${BEGINNING}"
    printf "${BLUE}[…]${NORMAL} $1${BLUE}...${NORMAL} "
}
log_ok_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$GREEN[✔]$NORMAL $1."
}
log_warn_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$YELLOW[⚡]$NORMAL $1!"
}
log_error_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$RED[✘]$NORMAL $1!"
    exit 1
}
log_info_msg () {
    printf "${BEGINNING}"
    echo "$BOLD$BLUE[∗]$NORMAL $1."
}

########################################################################
# Environment
#

check_dependencies() {
    log_begin_msg "Checking if dependencies are present"
    for exec in \
        busybox \
        strings \
        qemu-system-x86_64 \
        tmux vde_switch \
        start-stop-daemon \
        rsyslogd \
        $DEPENDENCIES; do
        which $exec 2> /dev/null > /dev/null || log_error_msg "$exec is not installed"
    done
    log_ok_msg "All dependencies are met"
}

setup_tmp () {
    TMP=$(mktemp -d)
    trap "ret=$? ; cleanup" EXIT
    log_info_msg "TMP is $TMP"
}

# Run our lab in tmux
setup_screen() {
    if [ -z "$TMUX" ] || [ x"$(tmux list-panes -F '#{session_name}')" != x"$LABNAME" ]; then
        unset TMUX
        exec tmux new-session -s "$LABNAME" -n main \
            "env ROOT=$ROOT VERSION=$VERSION LINUX=$LINUX $PROGNAME $PROGARGS || read"
    fi
    sleep 1
    tmux set-option -q prefix C-b
    tmux set-option -q set-remain-on-exit on
    tmux bind-key r respawn-window
}

display_help() {
    cat <<EOF

Some tmux commands (assuming default keybindings) :
 C-b d     - Detach the lab (resume with "tmux attach -t $LABNAME")
 C-b w     - Select a window
 C-b n     - Next window
 C-b p     - Previous window
 C-b l     - Last window
 C-b ?     - Get help
EOF
    echo "Press enter to exit the lab"
    read a
    done=1
}

# Setup a VDE switch
setup_switch() {
    nb=$1 ; shift
    [ ! -f "$TMP/switch-$nb.conf" ] || return 0
    log_begin_msg "Setup switch $nb"
    cat <<EOF > "$TMP/switch-$nb.conf"
plugin/add /usr/lib/vde2/plugins/pdump.so
pdump/filename $TMP/switch-$nb.pcap
pdump/buffered 0
pdump/active ${PCAP_ENABLED:-1}
EOF
    start-stop-daemon -b --no-close --make-pidfile --pidfile "$TMP/switch-$nb.pid" \
        --start --startas $(which vde_switch) -- \
        --sock "$TMP/switch-$nb.sock" --mgmt "$TMP/switch-management-$nb.sock" \
        --rcfile "$TMP/switch-$nb.conf" --hub
    # Management socket can be used with:
    #    socat - UNIX-CONNECT:"$TMP/switch-management-$nb.sock"
    log_ok_msg "Switch $nb started"
}

mac_address () {
    mac_counter=$(cat $TMP/mac-counter 2> /dev/null || echo 1)
    printf "50:54:33:00:%02X:%02X" \
           $((mac_counter / 256)) \
           $((mac_counter % 256))
    echo $((mac_counter + 1)) > $TMP/mac-counter
}

cleanup () {
    set +e
    [ x"$done" = x"1" ] || {
        printf "${BEGINNING}"
        echo "$BOLD$RED[✘]$NORMAL Got a fatal error. Press enter to terminate everything!"
        read a
    }
    for pid in $TMP/*.pid; do
        kill -15 -$(cat $pid) 2> /dev/null || true
    done
    sleep 1
    for pid in $TMP/*.pid; do
        kill -9 -$(cat $pid) 2> /dev/null || true
    done
    rm -rf $TMP
    tmux kill-session -t $LABNAME
}

########################################################################
# VM spawning
#

spawn () {
    [ x"$STATE" != x"SETUP" ] || return 0

    kind=$1
    shift

    NAME=$1
    shift

    NET=""

    while [ $# -gt 1 ]; do
        case $1 in
            network|networks)
                NET="$NET $2"
                NET="$(echo $NET | tr , ' ')"
                shift 2
                ;;
            *)
                log_error_msg "Unknown keyword for spawn \`$1'"
                ;;
        esac
    done

    for net in $NET; do
        setup_switch $net
    done
    sleep 0.5

    case $kind in
        vm)
            check_kernel
            setup_initrd
            start_vm
            ;;
        juniper-vrr)
            start_juniper_vrr
            ;;
        juniper-vsrx)
            start_juniper_vsrx
            ;;
        juniper-firefly)
            start_juniper_firefly
            ;;
        *)
            log_error_msg "Unknown kind of VM \`$kind'"
            ;;
    esac
}

check_kernel() {
    [ ! -f $TMP/kernel-checked ] || return 0
    log_begin_msg "Checking kernel version"
    [ -f "$KERNEL" ] || log_error_msg "Unable to find kernel $KERNEL"
    [ -r "$KERNEL" ] || log_error_msg "Kernel $KERNEL is not readable.\n    Try \`setfacl -m u:$USER:r $KERNEL'"

    # A recent version of `file` is able to extract the
    # information. Since it is not widely available, let use some hack
    # method.
    VERSION=$(cat <<EOF |
cat
gunzip  \\\037\\\213\\\010 xy
unxz    \\\3757zXZ\\\000   abcde
bunzip2 BZh                xy
unlzma  \\\135\\\0\\\0\\\0 xxx
EOF
              while read cmd sig1 sig2; do
                  case $sig1,$sig2 in
                      ,) poss="0:_" ;;
                      *) poss=$(tr "${sig1}\n${sig2}" "\n${sig2}=" < "$KERNEL" | grep -abo "^${sig2}" || true) ;;
                  esac
                  [ -n "$poss" ] || continue
                  for pos in $poss; do
                      pos=${pos%%:*}
                      tail -c+$pos "$KERNEL" | $cmd 2> /dev/null | strings -20 | \
                          grep ^Linux.version | head -1
                  done
              done | head -1)

    [ -n "$VERSION" ] || log_error_msg "Unable to determine version for $KERNEL"
    VERSION="${VERSION#Linux version }"
    VERSION="${VERSION%% *}"
    log_ok_msg "Found kernel $VERSION"

    log_begin_msg "Check kernel configuration"
    CONFIG="$(dirname $KERNEL)/config-$VERSION"
    CONFIG_REMOVE=0
    if [ ! -f "$CONFIG" ]; then
        if [ -f /proc/config.gz ]; then
            CONFIG=$(mktemp config.XXXXXXX)
            gunzip -c /proc/config.gz >$CONFIG
            CONFIG_REMOVE=1
        elif [ -f /proc/config ]; then
            CONFIG=/proc/config
        fi
    fi
    [ -f "$CONFIG" ] || log_error_msg "Unable to find configuration file $CONFIG"
    cat <<EOF | while read el; do
9P_FS=[ym]
NET_9P=[ym]
NET_9P_VIRTIO=[ym]
VIRTIO=[ym]
VIRTIO_PCI=[ym]
SERIAL_8250=y
SERIAL_8250_CONSOLE=y
TMPFS=y
BLK_DEV_INITRD=y
DEVTMPFS=[ym]
EOF
        grep -qx "CONFIG_$el" $CONFIG || log_error_msg "Kernel not configured with CONFIG_$el"
    done

    if grep -Eqc "CONFIG_OVERLAYFS_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. overlayfs present"
        UNION="${UNION}${UNION+ }overlayfs"
    elif grep -Eqc "CONFIG_OVERLAY_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. overlayfs present"
        UNION="${UNION}${UNION+ }overlay"
    fi
    if grep -qc "CONFIG_AUFS_FS=[ym]" $CONFIG; then
        log_ok_msg "Kernel configuration checked. AUFS present"
        UNION="${UNION}${UNION+ }aufs"
    fi
    [ -n "$UNION" ] || \
        log_error_msg "Kernel configuration checked. Neither overlayfs nor AUFS present"

    log_begin_msg "Search for modules"
    for dir in "$(dirname $KERNEL)/lib/modules/$VERSION" \
                   "$(dirname $KERNEL)/../lib/modules/$VERSION" \
                   "/lib/modules/$VERSION"; do
        [ -d $dir ] || continue
        MODULES="$dir"
        break
    done
    if [ -z "$MODULES" ]; then
        log_warn_msg "Unable to find module directory"
    else
        log_ok_msg "Modules are in $MODULES"
    fi
    : > $TMP/kernel-checked
    [ "$CONFIG_REMOVE" = "1" ] && rm "$CONFIG"
}

setup_initrd () {
    [ ! -f $TMP/initrd.gz ] || return 0
    log_begin_msg "Build initrd"
    DESTDIR=$TMP/initrd
    mkdir -p $DESTDIR

    # Copy busybox and eventually insmod
    bins="busybox"
    busybox --list | grep -qFx insmod || bins="$bins insmod"
    for bin in $bins; do
        install -D "$(which $bin)" ${DESTDIR}/bin/$bin
        for x in $(ldd "$(which $bin)" 2> /dev/null | sed -e '
               /\//!d;
               /linux-gate/d;
               /=>/ {s/.*=>[[:blank:]]*\([^[:blank:]]*\).*/\1/};
               s/[[:blank:]]*\([^[:blank:]]*\) (.*)/\1/' 2>/dev/null); do
            [ -f "${DESTDIR}/$x" ] || install -D "$x" "${DESTDIR}/$x"
        done
    done

    # Configure busybox
    for applet in $(${DESTDIR}/bin/busybox --list); do
        ln -s busybox ${DESTDIR}/bin/${applet}
    done

    # Add modules
    [ -z "$MODULES" ] || {
        modules="9pnet_virtio 9p virtio_pci $UNION"
        for mod in $modules; do
            base=${MODULES}/../../..
            cmd="modprobe --all --set-version=${VERSION} -d ${base} --ignore-install --quiet --show-depends $mod"
            $cmd > /dev/null || {
                depmod -b ${base} ${VERSION} 2> /dev/null && $cmd > /dev/null || {
                        log_warn_msg "Unable to find module $mod"
                        log_begin_msg "Continue building initrd"
                }
            }
            $cmd | while read prefix kmod options ; do
                [ "${prefix}" = "insmod" ] || continue
                grep -qFw "$kmod" ${DESTDIR}/modules 2> /dev/null || {
                    install -D "$kmod" "${DESTDIR}/${kmod}"
                    echo $prefix $kmod $options >> ${DESTDIR}/modules
                }
            done
        done
    }

    # Copy this program
    >  ${DESTDIR}/init echo '#!/bin/sh'
    >> ${DESTDIR}/init cat ../common/lab-setup
    chmod +x ${DESTDIR}/init

    # Create /tmp
    mkdir ${DESTDIR}/tmp

    # Build initrd
    (cd "${DESTDIR}" && find . | cpio --quiet -R 0:0 -o -H newc | gzip > $TMP/initrd.gz)

    log_ok_msg "initrd built in $TMP/initrd.gz"
}

start_vm () {
    name=$NAME
    netargs=""
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -net nic,model=virtio,macaddr=$mac,vlan=$net"
        netargs="$netargs -net vde,sock=$TMP/switch-$net.sock,vlan=$net"
    done

    log_info_msg "Start VM $name"
    # /root is mounted with version 9p2000.u to allow access to /dev,
    # /sys and to mount new partitions over them. This is not the case
    # for 9p2000.L.
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
echo
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(which qemu-system-x86_64) -- \
     -enable-kvm \
     -nodefconfig -nodefaults \
     -display none \
     -m ${MEM:-128M} \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     -chardev socket,id=charserial1,path=$TMP/vm-$name-serial.pipe,server,nowait \
     -device isa-serial,chardev=charserial1,id=serial1 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
     -mon chardev=con0,mode=readline,default \
     \
     -fsdev local,security_model=passthrough,id=fsdev-root,path=${ROOT} \
     -device virtio-9p-pci,id=fs-root,fsdev=fsdev-root,mount_tag=rootshare \
     -fsdev local,security_model=none,id=fsdev-home,path=${HOME} \
     -device virtio-9p-pci,id=fs-home,fsdev=fsdev-home,mount_tag=homeshare \
     -fsdev local,security_model=none,id=fsdev-lab,path=${PWD} \
     -device virtio-9p-pci,id=fs-lab,fsdev=fsdev-lab,mount_tag=labshare \
     -fsdev local,security_model=none,id=fsdev-common,path=${PWD}/../common,readonly \
     -device virtio-9p-pci,id=fs-common,fsdev=fsdev-common,mount_tag=commonshare \
     -fsdev local,security_model=none,id=fsdev-tmp,path=${TMP} \
     -device virtio-9p-pci,id=fs-tmp,fsdev=fsdev-tmp,mount_tag=tmpshare \
     -fsdev local,security_model=none,id=fsdev-modules,path=${MODULES}/..,readonly \
     -device virtio-9p-pci,id=fs-modules,fsdev=fsdev-modules,mount_tag=moduleshare \
     \
     -gdb unix:$TMP/vm-$name-gdb.pipe,server,nowait \
     -kernel $KERNEL \
     -no-reboot \
     -initrd $TMP/initrd.gz \
     -append "uts=$name console=ttyS0 panic=1 TERM=$TERM quiet" \
     $netargs
EOF
    log_info_msg "GDB server listening on $TMP/vm-$name-gdb.pipe"
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    log_info_msg "ttyS1 listening on      $TMP/vm-$name-serial.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux new-window -d -n $name "$TMP/vm-$name.exec"
}

start_juniper_vrr () {
    name=$NAME
    netargs=""
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -net nic,model=e1000,macaddr=$mac,vlan=$net"
        netargs="$netargs -net vde,sock=$TMP/switch-$net.sock,vlan=$net"
    done

    # Have a look at /etc/rc.vmguest for what is done
    log_info_msg "Start Juniper VRR $name"
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
qemu-img create -q -f qcow2 -b $PWD/../images/junos-vrr.img $TMP/junos-$name.img
truncate -s 10M $TMP/metadata-$name.img
mkfs.vfat $TMP/metadata-$name.img
mkdir -p $TMP/metadata-$name
cp junos-$name.conf $TMP/metadata-$name/juniper.conf
tar -C $TMP/metadata-$name -zcf $TMP/metadata-$name.tgz .
mcopy -i $TMP/metadata-$name.img $TMP/metadata-$name.tgz ::/vrr-config.tgz
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(which qemu-system-x86_64) -- \
     -enable-kvm \
     -nodefconfig -nodefaults \
     -display none \
     -m ${MEM:-1G} \
     -smbios type=0,vendor=Juniper -smbios type=1,manufacturer=Juniper,product=VRR \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     -usb -usbdevice disk:format=raw:$TMP/metadata-$name.img \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
     -mon chardev=con0,mode=readline,default \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux new-window -d -n $name "$TMP/vm-$name.exec"
    tmux set -w -t $name force-width 80
    tmux set -w -t $name force-heigh 25
}

start_juniper_vsrx () {
    name=$NAME
    netargs=""
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -net nic,model=e1000,macaddr=$mac,vlan=$net"
        netargs="$netargs -net vde,sock=$TMP/switch-$net.sock,vlan=$net"
    done

    log_info_msg "Start Juniper vSRX $name"
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
qemu-img create -q -f qcow2 -b $PWD/../images/junos-vsrx.img $TMP/junos-$name.img
mkdir -p $TMP/junos-$name-iso
cp junos-$name.conf $TMP/junos-$name-iso/juniper.conf
genisoimage -quiet -o $TMP/junos-$name.iso $TMP/junos-$name-iso
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(which qemu-system-x86_64) -- \
     -enable-kvm \
     -nodefconfig -nodefaults \
     -display none \
     -m ${MEM:-4G} \
     -smbios type=0,vendor=Juniper -smbios type=1,manufacturer=Juniper,product=VSRX \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     -drive file=$TMP/junos-$name.iso,if=ide,media=cdrom \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
     -mon chardev=con0,mode=readline,default \
     \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux new-window -d -n $name "$TMP/vm-$name.exec"
    tmux set -w -t $name force-width 80
    tmux set -w -t $name force-heigh 25
}

start_juniper_firefly () {
    # This is not the same as VSRX as the provisioning is different
    name=$NAME
    netargs=""
    for net in $NET; do
        mac=$(mac_address)
        netargs="$netargs -net nic,model=e1000,macaddr=$mac,vlan=$net"
        netargs="$netargs -net vde,sock=$TMP/switch-$net.sock,vlan=$net"
    done

    log_info_msg "Start Juniper vSRX $name"
    cat <<EOF > "$TMP/vm-$name.exec"
#!/bin/sh
qemu-img create -q -f qcow2 -b $PWD/../images/junos-firefly.img $TMP/junos-$name.img
mkdir -p $TMP/tftp
ln -s $PWD/junos-$name.conf $TMP/tftp/$name.conf
exec nice start-stop-daemon --make-pidfile --pidfile "$TMP/vm-$name.pid" \
     --start --startas $(which qemu-system-x86_64) -- \
     -enable-kvm \
     -nodefconfig -nodefaults \
     -display none \
     -machine pc \
     -cpu host \
     -smp cpus=2 \
     -rtc base="2014-06-09" \
     -smbios 'type=0,vendor=,version=' \
     -smbios 'type=1,product=,version=' \
     -m ${MEM:-512M} \
     \
     -boot c \
     -drive file=$TMP/junos-$name.img,if=ide,media=disk \
     \
     -chardev stdio,id=charserial0,signal=off \
     -device isa-serial,chardev=charserial0,id=serial0 \
     \
     -chardev socket,id=con0,path=$TMP/vm-$name-console.pipe,server,nowait \
     -mon chardev=con0,mode=readline,default \
     \
     -net nic,model=e1000,macaddr=$(mac_address),vlan=4095 \
     -net user,vlan=4095,tftp=$TMP/tftp,hostname=$name \
     $netargs
EOF
    log_info_msg "monitor listening on    $TMP/vm-$name-console.pipe"
    chmod +x "$TMP/vm-$name.exec"
    tmux new-window -d -n $name "$TMP/vm-$name.exec"
    tmux set -w -t $name force-width 80
    tmux set -w -t $name force-heigh 25
}

########################################################################
# Services
#

execute () {
    command="$1"
    shift
    for command in /mnt/common/bin/"$command" "$command"; do
        [ ! -x "$command" ] || break
    done
    if [ -n "$netns" ]; then
        ip netns exec $netns "$command" "$@"
    else
        "$command" "$@"
    fi
}

service () {
    kind=$1
    shift

    case $kind in
        nginx)
            log_begin_msg "Running nginx"
            mkdir /var/log/nginx
            mkdir -p /tmp/nginx/www
            echo $uts > /tmp/nginx/www/index.html
            for size in 10M 100M 1G 10G 100G; do
                dd if=/dev/zero of=/tmp/nginx/www/$size bs=1 count=1 seek=$size 2> /dev/null
            done
            nginxconf=/mnt/common/nginx.conf
            [ -f /mnt/lab/nginx.conf ] && nginxconf=/mnt/lab/nginx.conf
            execute nginx -c "$nginxconf"
            log_ok_msg "nginx started"
            ;;
        bird)
            log_begin_msg "Running bird${netns+, netns=}$netns"
            [ -d /run/bird ] || mkdir -p /run/bird
            [ ! -f /mnt/lab/bird.$uts.$netns.conf ]  || execute bird -R -s /var/run/bird.$netns.ctl -c /mnt/lab/bird.$uts.$netns.conf
            [ ! -f /mnt/lab/bird6.$uts.$netns.conf ] || execute bird6 -R -s /var/run/bird6.$netns.ctl -c /mnt/lab/bird6.$uts.$netns.conf
            [ ! -f /mnt/lab/bird.$uts.conf ]  || [ -n "$netns" ] || execute bird  -R -c /mnt/lab/bird.$uts.conf
            [ ! -f /mnt/lab/bird6.$uts.conf ] || [ -n "$netns" ] || execute bird6 -R -c /mnt/lab/bird6.$uts.conf
            log_ok_msg "bird started${netns+, netns=}$netns"
            ;;
        gobgp)
            log_begin_msg "Running gobgp"
            execute gobgpd -f /mnt/lab/gobgp.$uts.conf -t yaml -p -s unix --disable-stdlog &
            log_ok_msg "gobgp started"
            ;;
        radvd)
            cfg="${1:-radvd.$uts.conf}"
            log_begin_msg "Running radvd ($cfg)"
            execute radvd -l /var/log/radvd.log -u radvd -C /mnt/lab/"$cfg"
            log_ok_msg "radvd started ($cfg)"
            ;;
        ndppd)
            cfg="${1:-ndppd.$uts.conf}"
            log_begin_msg "Running ndppd ($cfg)"
            execute ndppd -d -c /mnt/lab/"$cfg"
            log_ok_msg "ndppd started ($cfg)"
            ;;
        dnsmasq)
            log_begin_msg "Running dnsmasq"
            mkdir /var/run/dnsmasq
            execute dnsmasq \
                --conf-file=/dev/null \
                --no-hosts \
                --user=root \
                --dhcp-leasefile=/tmp/dnsmasq.leases \
                "$@"
            log_ok_msg "dnsmasq started"
            ;;
        *)
            log_begin_msg "Running $kind"
            execute "$kind" "$@"
            log_ok_msg "$kind started"
            ;;
    esac
}

run () {
    [ x"$STATE" != x"SETUP" ] || return 0
    display_help
    exit 0
}

########################################################################
# FSM
#

export STATE=${STATE:-BEGIN}
case $$,$STATE in
    1,BEGIN)
        # In initrd
        log_info_msg "initrd started"
        hostname ${uts}
        export PATH=/usr/local/bin:/usr/bin:/bin:/sbin:/usr/local/sbin:/usr/sbin
        export HOME=/root

        [ ! -f /modules ] || {
            log_info_msg "Loading modules"
            . /modules
        }

        log_begin_msg "Setup root file system"
        mount -n -t tmpfs tmpfs /tmp -o rw
        mkdir /tmp/target
        mkdir /tmp/target/ro
        mkdir /tmp/target/overlay
        mount -n -t 9p    rootshare /tmp/target/ro      -o trans=virtio,version=9p2000.u,ro
        mkdir /tmp/target/rw
        mount -n -t tmpfs tmpfs     /tmp/target/rw      -o rw
        mkdir /tmp/target/rw/workdir
        mkdir /tmp/target/rw/upperdir
        mount -n -t aufs aufs /tmp/target/overlay \
              -o noxino,noatime,dirs=/tmp/target/rw/upperdir:/tmp/target/ro=ro \
              2> /dev/null || \
            mount -n -t overlayfs overlayfs /tmp/target/overlay \
                  -o lowerdir=/tmp/target/ro,upperdir=/tmp/target/rw/upperdir,noatime \
                  2> /dev/null || \
            mount -n -t overlay overlayfs /tmp/target/overlay \
                  -o lowerdir=/tmp/target/ro,upperdir=/tmp/target/rw/upperdir,workdir=/tmp/target/rw/workdir,noatime \
                  2> /dev/null ||
            log_error_msg "Unable to mount AUFS/overlayfs"
        mount -n -t proc  proc /tmp/target/overlay/proc
        mount -n -t sysfs sys  /tmp/target/overlay/sys
        log_ok_msg "Root file system setup"

        log_begin_msg "Clean /tmp and /run"
        for fs in /run /var/run /var/tmp /var/log /tmp /mnt; do
            if [ -d /tmp/target/overlay$fs ] && [ ! -h /tmp/target/overlay$fs ]; then
                mount -t tmpfs tmpfs /tmp/target/overlay$fs -o rw,nosuid,nodev
            fi
        done
        log_ok_msg "/tmp, /run and others are clean"

        log_begin_msg "Mount /root"
        mount -t 9p homeshare /tmp/target/overlay/root -o trans=virtio,version=9p2000.L,access=any,rw || \
            log_error_msg "Unable to mount /root"
        [ ! -d /tmp/target/overlay/root/.ssh ] || {
            mount -t tmpfs tmpfs /tmp/target/overlay/root/.ssh -o rw,nosuid,nodev
            chmod 0700 /tmp/target/overlay/root/.ssh
        }
        log_ok_msg "/root mounted"
        log_begin_msg "Mount /lib/modules"
        mount -t 9p moduleshare /tmp/target/overlay/lib/modules -o trans=virtio,version=9p2000.L,access=0,ro || \
            log_error_msg "Unable to mount /lib/modules"
        log_ok_msg "/root and /lib/modules mounted"

        log_begin_msg "Mount /mnt/lab"
        mkdir /tmp/target/overlay/mnt/lab /tmp/target/overlay/mnt/common
        mount -t 9p labshare /tmp/target/overlay/mnt/lab -o trans=virtio,version=9p2000.L,access=any,rw || \
            log_error_msg "Unable to mount /mnt/lab"
        mount -t 9p commonshare /tmp/target/overlay/mnt/common -o trans=virtio,version=9p2000.L,access=any,ro || \
            log_error_msg "Unable to mount /mnt/common"
        log_ok_msg "/mnt/lab and /mnt/common mounted"

        log_begin_msg "Mount /tmp/lab"
        mkdir /tmp/target/overlay/tmp/lab
        mount -t 9p tmpshare /tmp/target/overlay/tmp/lab -o trans=virtio,version=9p2000.L,access=any,rw || \
            log_error_msg "Unable to mount /tmp/lab"
        log_ok_msg "/tmp/lab mounted"

        log_info_msg "Change root"
        export STATE=CHROOTED
        exec chroot /tmp/target/overlay /mnt/lab/setup
        ;;

    1,CHROOTED)
        log_begin_msg "Starting udev"
        udev_log=err
        mount -n -o size=10M,mode=0755 -t devtmpfs devtmpfs /dev
        rm -f /etc/udev/rules.d/70-persistent-net.rules
        udevadm info --cleanup-db
        for udev in /lib/systemd/systemd-udevd /usr/lib/systemd/systemd-udevd $(command -v udevd 2> /dev/null); do
            [ ! -x $udev ] || break
        done
        $udev --daemon
        udevadm trigger --action=add
        udevadm settle
        log_ok_msg "udev started"

        log_info_msg "Setup interfaces"
        modprobe dummy 2>/dev/null || true
        sleep 0.5               # Some interfaces may take some time to appear
        i=0
        for intf in /sys/class/net/*; do
            intf=${intf##*/}
            ip a l dev $intf 2> /dev/null >/dev/null || continue
            case $intf in
                ens*)
                    ip link set name eth$i dev $intf
                    intf=eth$i
                    i=$(( i + 1 ))
                    ;;
            esac
            ip link set up dev $intf
            # Instead of waiting for DAD to finish, just disable it
            sysctl -qw net/ipv6/conf/$intf/accept_dad=0
        done
        sysctl -qw net/ipv6/conf/default/accept_dad=0

        log_info_msg "Start syslog"
        rsyslogd

        log_info_msg "Setup terminal"
        unset SHLVL
        export STATE=GETTY
        exec setsid /sbin/agetty -L ttyS0 -a root -l /mnt/lab/setup -i 115200 $TERM
        ;;

    1,GETTY)
        log_begin_msg "Setup terminal size"
        # We are guaranteed to be in a tmux session, so we will get an
        # answer to the escape code we send. Otherwise, we may just
        # block!
        stty -echo
        stty raw
        printf '[18t'
        width=
        height=
        p=0
        while true; do
            char="$(timeout --foreground 1s dd bs=1 count=1 2> /dev/null || true)"
            case "$p,$char" in
                "0,;")
                    # End of CSI
                    p=1
                    ;;
                "1,;")
                    # End of height
                    stty rows $height
                    p=2
                    ;;
                "1,"*)
                    height="$height$char"
                    ;;
                "2,t"|"2,")
                    # End of width
                    stty columns $width
                    p=3
                    ;;
                "2,"*)
                    width="$width$char"
                    ;;
            esac
            [ x"$p" != x"3" ] || break
        done
        stty -raw
        stty echo
        log_ok_msg "Terminal size is $(tput cols)x$(tput lines)"

        log_begin_msg "Setup additional commands"
        mkdir /tmp/tools
        export PATH=/tmp/tools:$PATH
        cat <<EOF > /tmp/tools/reboot
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        cat <<EOF > /tmp/tools/halt
#!/bin/sh
echo b > /proc/sysrq-trigger
EOF
        chmod +x /tmp/tools/*
        log_ok_msg "System can be halted with halt or reboot"

        export STATE=SETUP
        . /mnt/lab/setup

        while true; do
            log_info_msg "Spawning a shell"
            cd $HOME
            export SSH_TTY=$(tty)
            if [ -f $HOME/.zshrc ]; then
                /bin/zsh -i
            else
                /bin/bash -i
            fi || sleep 1
        done
        ;;

    *,BEGIN)
        [ $(id -u) != 0 ] || {
            log_error_msg "You should not run this as root"
            exit 1
        }
        PROGNAME="$(readlink -f "$0")"
        PROGARGS="$@"
        ROOT="$(readlink -f "${ROOT:-/}")" # Root filesystem
        KERNEL="$(readlink -f "${1:-/boot/vmlinuz-$(uname -r)}")" # Kernel
        [ ! -f "$KERNEL" ] && KERNEL=$(readlink -f /boot/vmlinuz-linux)  # Archlinux
        PATH="$PATH":/usr/local/sbin:/usr/sbin:/sbin
        [ $# -lt 1 ] || shift
        check_dependencies
        setup_screen
        setup_tmp
        ;;
esac

# Local Variables:
# mode: sh
# indent-tabs-mode: nil
# sh-basic-offset: 4
# End:
